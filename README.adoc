# Java GADT Generator

This is simple code generation library and http://maven.apache.org[plugin for Apache Maven] to generate _immutable_, _algebraic data types_ for the JVM.

## Compile time dependencies

The code generated by `gadt-maven-plugin` uses the https://github.com/google/auto/tree/master/value[Google Auto-Value] annotations to generate it's immutable classes, so this is required to be listed as a `compile` dependency in your maven project.

NOTE: There are _no_ run-time dependencies introduced by the GADT Generator project.

## Example GADT File

.Request.gadt
[source,haskell]
----
-- A simple model for an HTTP based API
package com.theoryinpractise.gadt.examples;

data Request
  = GET(path : java.lang.String)
  | DELETE(path : java.lang.String)
  | POST(path : java.lang.String, body : java.lang.String);
  
data Day = Monday() | Tuesday() | Wednesday() | Thursday()
         | Friday() | Saturday() | Sunday();
----
1. The destination `package` for the generated classes *MUST* be specified.
2. Type declarations _currently_ require parentheses _without whitespace_ and a terminating `;` character.

### Generated Classes

A top level `abstract` class is generated for each top level datatype, with additional `abstract` subclasses for each individual datatype case, these classes are annotatd with `@AutoValue` and will generate concrete, immutable, private instance classes via the Google Autovalue library.

Static methods on the top level class are provided to construct instances of your dataypes.

An inner `Matcher` interface is also generated, containing a separate `match` method for each unique datatype case:

[source,java]
----
public interface Matcher<Return> {
  Return match(Request.GET GET);
  Return match(Request.DELETE DELETE);
  Return match(Request.POST POST);
}
----

which is used in conjunction with the instance level `match` method defined in the top level abstract class, this is used as such:

[source,java]
----
int pathLength = req.match(new Request.Matcher() {
  @Override
  public Integer match(Request.GET GET) {
    return GET.path().length();
  }

  @Override
  public Integer match(Request.DELETE DELETE) {
    return DELETE.path().length();
  }

  @Override
  public Integer match(Request.POST POST) {
    return POST.path().length();
  }
});

----

The constructor methods return their concrete type, allowing local code to easily access the types members.

----
Request.GET("/api/story/32").path()
----

### Supporting Super-Type marker interfaces

[source,java]
----
data SomeType implements [some.marker.Interface, some.other.Interface]
  = Value();
----

Data Type declarations define a list of Java class names that the base class should `implement`. These classes *MUST* be interfaces, and only contain `static` or `default` methods ( otherwise the generated code will be fail to compile ).

[NOTE]
====
I really don't like the `[]` style syntax, but as yet I'm not sure yet how to get the  https://github.com/jparsec/jparsec[jparsec] parser library to terminate the CSV list without failing the parse. This is being tracked as https://github.com/talios/javagadt/issues/8[issue #8].
====

## Configuring Your Maven Build

.pom.xml
[source,xml]
----
<plugins>
  <plugin>
    <groupId>com.theoryinpractise.gadt</groupId>
    <artifactId>gadt-maven-plugin</artifactId>
    <version>1.0.1-SNAPSHOT</version>
    <executions>
      <execution>
        <id>gadt</id>
        <goals>
          <goal>gadt</goal>
        </goals>
      </execution>
    </executions>
  </plugin>
</plugins>
...
<dependencies>
  <dependency>
    <groupId>com.google.auto.value</groupId>
    <artifactId>auto-value</artifactId>
    <version>1.1</version>
    <scope>provided</scope>
  </dependency>
</dependencies>
----
