# Java GADT Generator
:toc:
:toc-placement: preamble

Algebraic Data-Types for Java.

`gadt-maven-plugin` is an http://maven.apache.org[Apache Maven] plugin to generate _immutable_, _algebraic data types_ for use in JDK 8 based projects.

## Example GADT File

.Request.gadt
[source,haskell]
----
-- A simple model for an HTTP based API
package com.theoryinpractise.gadt.examples;

-- By not specifying the return type with "->" for a given case,
-- the inferred return type should just be the individual case.
data Request implements (com.theoryinpractise.gadt.Shouter)
  = GET    (path : String)
  | DELETE (path : String)
  | POST   (path : String, body : String);

-- By not specifying any arguments for a data type, it is generated as a
-- singleton instance which could be used in place of standard enums.
data Day
  = Monday | Tuesday | Wednesday
  | Thursday | Friday | Saturday | Sunday;

-- java.lang is "imported" by default, but if you want to use other classes,
-- simply import them

import java.util.Date;

data Log
  = info(date: Date, message: String)
  | debug(date: Date, message: String)
  | warn(date: Date, message: String)
  | error(date: Date, message: String);
----

### Generated Classes

* A top level `abstract` class acting as a _module_ for the datatype.
* Separate _inner classes_ and _constructor functions_ for each alterative type.
* A _matcher_ interface providing total coverage for each alternative type.
* A _fluent matching_ class for simple, inline matching.

A top level `abstract` class is generated for each top level datatype, with additional `abstract` subclasses for each individual datatype case, these classes are annotatd with `@AutoValue` and will generate concrete, immutable, private instance classes via the Google Autovalue library.

Static methods on the top level class are provided to construct instances of your dataypes.

The constructor methods return their concrete type, allowing local code to easily access the types members.

----
Request.GET("/api/story/32").path()
----


## Matching values

### Total Match Coverage via Visitor

An inner `Matcher` interface is also generated, containing a separate `match` method for each unique datatype case:

[source,java]
----
public interface Matcher<Return> {
  Return match(Request.GET GET);
  Return match(Request.DELETE DELETE);
  Return match(Request.POST POST);
}
----

which is used in conjunction with the instance level `match` method defined in the top level abstract class, this is used as such:

[source,java]
----
int pathLength = req.match(new Request.Matcher() {
  @Override
  public Integer match(Request.GET GET) {
    return GET.path().length();
  }

  @Override
  public Integer match(Request.DELETE DELETE) {
    return DELETE.path().length();
  }

  @Override
  public Integer match(Request.POST POST) {
    return POST.path().length();
  }
});

----

### Fluent Matchers

Java GADT supports an alternate matching style based on a chainable lambda syntax:

[source,java]
----
Request.Matching<Integer> matched = req.matching()
  .GET( get -> get.path().length() );
  
if (matched.isMatched()) {
  int length = matched.get();
}

int length = req.<Integer>matching()
  .GET( get -> get.path().length() )
  .orElse(0);

----

The generated `Request.Matching` class is somewhat akin to an `Optional` value, the only difference being individual type case methods providing a functional style match expression.




### Supporting Super-Type marker interfaces

[source,java]
----
data SomeType implements (some.marker.Interface, some.other.Interface)
  = Value();
----

Data Type declarations define a list of Java class names that the base class should `implement`. These classes *MUST* be interfaces, and only contain `static` or `default` methods ( otherwise the generated code will be fail to compile ).

[NOTE]
====
I really don't like the `[]` style syntax, but as yet I'm not sure yet how to get the  https://github.com/jparsec/jparsec[jparsec] parser library to terminate the CSV list without failing the parse. This is being tracked as https://github.com/talios/javagadt/issues/8[issue #8].
====

## Compile time dependencies

The code generated by `gadt-maven-plugin` uses the https://github.com/google/auto/tree/master/value[Google Auto-Value] annotations to generate it's immutable classes, so this is required to be listed as a `compile` dependency in your maven project.

NOTE: There are _no_ run-time dependencies introduced by the GADT Generator project.


## Configuring Your Maven Build

### Standard Usage

.pom.xml
[source,xml]
----
<plugins>
  <plugin>
    <groupId>com.theoryinpractise.gadt</groupId>
    <artifactId>gadt-maven-plugin</artifactId>
    <version>1.0.1-SNAPSHOT</version>
    <executions>
      <execution>
        <id>gadt</id>
        <goals>
          <goal>gadt</goal>
        </goals>
      </execution>
    </executions>
  </plugin>
</plugins>
...
<dependencies>
  <dependency>
    <groupId>com.google.auto.value</groupId>
    <artifactId>auto-value</artifactId>
    <version>1.1</version>
    <scope>provided</scope>
  </dependency>
</dependencies>
----

### Maven Tiles Usage

[source,xml]
----
<plugins>
  <plugin>
    <groupId>io.repaint.maven</groupId>
    <artifactId>tiles-maven-plugin</artifactId>
    <version>2.2</version>
    <extensions>true</extensions>
    <configuration>
      <tiles>
        <tile>com.theoryinpractise.gadt:gadt-maven-tile:[1.0.0,2.0.0)</tile>
      </tiles>
    </configuration>
  </plugin>
</plugins>
----
